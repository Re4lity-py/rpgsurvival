<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Survival RPG ULTIMATE - V9</title>
<style>
    /* --- CSS GLOBAL --- */
    * { box-sizing: border-box;
user-select: none; -webkit-user-select: none; touch-action: none; font-family: 'Pixelated MS Sans Serif', 'Segoe UI', sans-serif;
}
    body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: #000; overflow: hidden;
}
    
    #gameCanvas { display: block; width: 100%; height: 100%; image-rendering: pixelated;
}
    #rotate-msg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #2c3e50; color: #fff;
display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 99999; text-align: center;
}

    /* --- UI --- */
    .ui-layer { position: absolute; top: 0; left: 0;
width: 100%; height: 100%; pointer-events: none; }
    
    .hud { position: absolute; top: 10px;
left: 10px; background: rgba(20,20,20,0.9); color: #fff; padding: 8px; border-radius: 8px; border: 2px solid #555; font-size: 13px; font-weight: bold; display: flex;
flex-direction: column; gap: 5px; pointer-events: auto; max-width: 200px; }
    .hud-row { display: flex; justify-content: space-between; gap: 10px;
}

    /* NOUVEAU CONTENEUR pour Qu√™te + Carte */
    .top-right-ui { position: absolute;
top: 10px; right: 10px; display: flex; align-items: flex-start; gap: 10px;
}
    
    .quest-box { background: rgba(0,0,0,0.6); color: #f1c40f; padding: 10px; border-radius: 5px;
border-left: 4px solid #f1c40f; font-size: 14px; max-width: 250px; text-align: right; pointer-events: none; }
    .quest-title { font-weight: 900;
text-transform: uppercase; font-size: 11px; letter-spacing: 1px; color: #aaa; }
    
    /* MINI-MAP DEVIENT UN BOUTON */
    #map-btn { width: 50px;
height: 50px; border-radius: 10px; background: #3498db; border: 2px solid #fff; display: flex; justify-content: center; align-items: center; font-size: 24px; pointer-events: auto;
cursor: pointer; box-shadow: 0 4px 0 #2980b9; transition: background 0.2s; }
    #map-btn:active { transform: translateY(4px); box-shadow: none;
}
    
    #menu-btn { width: 50px; height: 50px; background: #e67e22; border-radius: 10px;
border: 2px solid #fff; font-size: 24px; display: flex; justify-content: center; align-items: center; pointer-events: auto; cursor: pointer;
box-shadow: 0 4px 0 #d35400; }
    #menu-btn:active { transform: translateY(4px); box-shadow: none;
}
    
    .controls { position: absolute; bottom: 20px; right: 20px; pointer-events: auto;
}
    #action-btn { width: 100px; height: 100px; background: #c0392b; border-radius: 50%; border: 5px solid #fff; display: flex;
justify-content: center; align-items: center; font-size: 40px; box-shadow: 0 5px 0 #922b21; transition: background 0.2s;
}
    
    #joystick-zone { position: absolute; bottom: 30px; left: 10px; width: 120px; height: 120px;
background: rgba(255,255,255,0.1); border-radius: 50%; border: 2px solid rgba(255,255,255,0.3); pointer-events: auto;
}
    
    /* NOUVEAU: Cacher les contr√¥les tactiles sur PC */
    @media (min-width: 801px) {
        #joystick-zone, .controls {
            display: none !important;
        }
    }

    /* MENUS & MODALS */
    .modal { position: absolute;
top: 50%; left: 50%; transform: translate(-50%, -50%); background: #2c3e50; width: 80%; max-width: 600px; border: 4px solid #fff; border-radius: 15px;
display: none; z-index: 5000; padding: 20px; color: #fff; pointer-events: auto; box-shadow: 0 0 50px #000; overflow-y: auto; text-align: center;
}
    .modal h2 { color: #f1c40f; margin-top: 0; border-bottom: 1px solid #555; padding-bottom: 10px;
}
    
    .craft-row { display: flex; justify-content: space-between; align-items: center; background: rgba(0,0,0,0.2); padding: 10px;
margin-bottom: 8px; border-radius: 5px; border: 1px solid #444; }
    .btn { background: #27ae60; color: white; border: none;
padding: 8px 16px; border-radius: 4px; font-weight: bold; border-bottom: 3px solid #1e8449; }
    .btn:active { border-bottom: 0;
transform: translateY(3px); }
    .btn:disabled { background: #7f8c8d; border-bottom: 3px solid #555; opacity: 0.5;
}
    .close-modal { width: 100%; background: #c0392b; border-bottom: 4px solid #922b21; padding: 15px; font-size: 18px; margin-top: 20px;
}
    
    /* DEATH MENU SPECIFIC */
    #death-screen { background: rgba(192, 57, 43, 0.95);
border-color: #e74c3c; width: 90%; max-width: 400px; }
    
    /* FULL MAP MODAL */
    #map-modal { max-width: 90vw;
max-height: 90vh; width: auto; height: auto; padding: 10px; }
    #fullMapCanvas { border: 2px solid #fff; background: #000;
}

</style>
</head>
<body>

<div id="rotate-msg"><h1>üì± TOURNEZ L'√âCRAN</h1><p>Jeu optimis√© pour le mode Paysage</p></div>

<canvas id="gameCanvas"></canvas>
<div id="night-overlay" style="position:absolute;top:0;left:0;width:100%;height:100%;background:black;pointer-events:none;opacity:0;z-index:10;"></div>

<div class="ui-layer">
    <div id="save-notif" style="position:absolute;top:70px;left:50%;transform:translateX(-50%);background:#27ae60;color:white;padding:5px 15px;border-radius:5px;display:none;z-index:5001;">üíæ Sauvegarde auto...</div>

    <div class="hud">
        <div class="hud-row" style="color:#e74c3c; border-bottom:1px solid #444; padding-bottom:5px; margin-bottom:5px;">
            <span>‚ù§Ô∏è VIE</span> <span id="hud-hp">100/100</span>
        </div>
        <div class="hud-row"><span>ü™µ Bois</span> <span id="hud-wood">0</span></div>
        <div class="hud-row"><span>ü™® Pierre</span> <span id="hud-stone">0</span></div>
        <div class="hud-row"><span>üü° Or</span> <span 
id="hud-gold">0</span></div>
        <div class="hud-row"><span>‚ö™ Fer</span> <span id="hud-iron">0</span></div>
        <div class="hud-row"><span>‚ö´ Obsi</span> <span id="hud-obsi">0</span></div>
    </div>
    
    <div class="top-right-ui">
        <div id="map-btn" onclick="showFullMapModal()">üîç</div>
        <div id="menu-btn">‚öôÔ∏è</div>
    </div>

    <div class="quest-box">
        <div class="quest-title">OBJECTIF ACTUEL</div>
        <div id="quest-txt">Chargement...</div>
    </div>
    
    <div id="joystick-zone"><div id="joystick-stick" style="position: 
absolute; width: 50px; height: 50px; background: rgba(255,255,255,0.8); border-radius: 50%; top: 35px;
left: 35px;"></div></div>
    <div class="controls"><div id="action-btn"></div></div>
</div>

<div id="craft-menu" class="modal">
    <h2>üõ†Ô∏è FORGE & ARTISANAT</h2>
    <div class="craft-row" style="border-color:#f39c12;
background:rgba(243,156,18,0.1);">
        <div><strong>üè† BASE / SOIN (Niv <span id="house-lvl">0</span>)</strong><br><small id="house-desc">Soin passif √† domicile</small><br><span class="cost" id="house-cost">...</span></div>
        <button class="btn" id="btn-house" onclick="game.craft('house')">B√ÇTIR</button>
    </div>
    <div class="craft-row" style="border-color:#3498db;
background:rgba(52,152,219,0.1);">
        <div><strong>üõ°Ô∏è ARMURE (Niv <span id="armor-lvl">0</span>)</strong><br><small>+PV Max (Base requise)</small><br><span class="cost" id="armor-cost">...</span></div>
        <button class="btn" id="btn-armor" onclick="game.craft('armor')">FORGER</button>
    </div>
    <h3>OUTILS</h3>
    <div class="craft-row"><div>ü™ì <strong>HACHE</strong> <small id="axe-lvl-menu">Niv 1</small><br><span class="cost" id="axe-cost">...</span></div><button class="btn" id="btn-axe" onclick="game.craft('axe')">UP</button></div>
    <div class="craft-row"><div>‚õèÔ∏è <strong>PIOCHE</strong> <small id="pick-lvl-menu">Niv 1</small><br><span class="cost" id="pick-cost">...</span></div><button class="btn" id="btn-pick" onclick="game.craft('pick')">UP</button></div>
    <div class="craft-row"><div>‚öîÔ∏è <strong>√âP√âE</strong> <small id="sword-lvl-menu">Niv 1</small><br><span class="cost" id="sword-cost">...</span></div><button class="btn" id="btn-sword" onclick="game.craft('sword')">UP</button></div>

    <button class="btn close-modal" onclick="document.getElementById('craft-menu').style.display='none'">RETOUR JEU</button>
</div>

<div id="map-modal" class="modal">
    <h2>üó∫Ô∏è CARTE DU MONDE (4000x4000)</h2>
    
<canvas id="fullMapCanvas" width="500" height="500"></canvas>
    <button class="btn close-modal" onclick="document.getElementById('map-modal').style.display='none'">FERMER CARTE</button>
</div>

<div id="death-screen" class="modal">
    <h2>üíÄ MORT !</h2>
    <p>Ton aventure s'arr√™te ici.
Que souhaites-tu faire ?</p>
    <div class="death-options">
        <button class="btn" id="btn-restart" onclick="deathMenuAction('restart')">üéÆ Tout Recommencer</button>
        <button class="btn" id="btn-respawn" onclick="deathMenuAction('respawn')">üè° Revenir √† la Maison</button>
    </div>
</div>

<script>
/**
 * SURVIVAL RPG ULTIMATE V9 - Zone S√©curis√©e & Carte Compl√®te
 * MODIFICATIONS PC ZQSD & SOURIS
 */

// --- CONSTANTES & PALETTE (Pixel Art Data) ---
const WORLD_W = 4000;
const WORLD_H = 4000;
const SCALE_BASE = 4; // Taille d'un pixel dans le jeu
const SAFE_ZONE_X = 500;
// Nouvelle zone sans mobs de 0 √† 500 X

const PALETTE = [
    'rgba(0,0,0,0)', '#000000', '#FFFFFF', '#8b4513', '#2ecc71', 
    '#95a5a6', '#e74c3c', '#f1c40f', '#3498db', '#e91e63', 
    '#bdc3c7', '#1c2833', '#1e8449' // 12: Dark Green (Forest on Map)
];
// ... PIXEL_ASSETS (Non r√©p√©t√© ici pour la taille, mais il est dans la version finale)
const PIXEL_ASSETS = {
    PLAYER_IDLE: [
        [0,0,1,1,1,1,0,0], [0,1,6,2,2,6,1,0], [0,1,6,2,2,6,1,0], [0,0,1,3,3,1,0,0],
        [0,0,1,3,3,1,0,0], [0,0,1,2,2,1,0,0], [0,0,1,3,3,1,0,0], [0,1,3,0,0,3,1,0]
    ],
    PLAYER_SWORD: [
        [1,0,0,0,0,0,0,0], [1,1,0,0,0,0,0,0], [0,1,1,0,0,0,0,0], [0,0,1,1,1,1,1,0],
        [0,0,1,3,3,1,0,0], [0,0,1,2,2,1,0,0], [0,0,1,3,3,1,0,0], [0,1,3,0,0,3,1,0]
    ],
    TREE: [
        [0,0,4,4,4,4,0,0], [0,4,4,4,4,4,4,0], [4,4,4,4,4,4,4,4], [0,0,0,3,3,0,0,0],
    
    [0,0,0,3,3,0,0,0], [0,0,0,3,3,0,0,0], [0,0,0,3,3,0,0,0], [0,0,0,3,3,0,0,0]
    ],
    STONE: [
        [0,0,5,5,5,5,0,0], [0,5,5,5,5,5,5,0], [5,5,5,1,5,5,5,5], [5,5,1,5,5,5,5,5],
        [0,5,5,5,5,5,5,0], [0,0,5,5,5,0,0,0], [0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0]
    ],
    SLIME: [
        [0,0,4,4,4,4,0,0], [0,4,4,4,4,4,4,0], [4,4,4,4,4,4,4,4], [4,4,1,4,4,1,4,4],
        [4,4,4,4,4,4,4,4], [0,4,4,1,1,4,4,0], [0,0,4,4,4,4,0,0], [0,0,0,0,0,0,0,0]
    ],
    HOUSE_LVL1: [
        [0,0,0,1,1,0,0,0], [0,0,1,6,6,1,0,0], [0,1,3,3,3,3,1,0], [1,3,3,3,3,3,3,1],
        [1,3,2,1,1,2,3,1], [1,3,2,1,1,2,3,1], [1,3,3,3,3,3,3,1], 
[1,1,1,1,1,1,1,1]
    ],
    HOUSE_LVL2: [
        [0,0,1,2,2,1,0,0], [0,1,3,3,3,3,1,0], [1,3,7,7,7,7,3,1], [1,3,7,2,2,7,3,1],
        [1,3,7,2,2,7,3,1], [1,3,7,7,7,7,3,1], [1,3,3,3,3,3,3,1], [1,1,1,1,1,1,1,1]
    ],
    ROCK_GOLD: [
        [0,7,7,7,7,0,0,0], [7,7,5,5,5,7,7,0], [7,5,5,7,5,5,7,7], [5,7,5,5,5,5,7,0],
        [5,5,7,7,5,5,0,0], [0,5,5,5,0,0,0,0], [0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0]
    ],
    SCORPION: [
        [1,0,0,0,0,0,0,1], [0,1,0,0,0,0,1,0], [0,0,1,1,1,1,0,0], [0,0,1,6,6,1,0,0],
        [0,0,1,1,1,1,0,0], [0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0]
    ],
   
 IRON_ROCK: [
        [0,0,10,10,10,10,0,0], [0,10,5,5,5,10,10,0], [10,5,5,10,5,5,10,10], [5,10,5,5,5,5,10,0],
        [5,5,10,10,5,5,0,0], [0,5,5,5,0,0,0,0], [0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0]
    ],
    WOLF: [
        [0,1,1,0,0,1,1,0], [1,2,2,1,1,2,2,1], [1,2,2,2,2,2,2,1], [0,1,2,2,2,2,1,0],
        [0,0,1,2,2,1,0,0], [0,0,1,1,1,1,0,0], [0,0,1,0,0,1,0,0], [0,0,1,0,0,1,0,0]
    ],
    RUBY: [
        [0,0,0,9,9,0,0,0], [0,0,9,9,9,9,0,0], [0,9,9,1,1,9,9,0], [9,9,1,9,9,1,9,9],
        [9,1,9,9,9,9,1,9], [9,9,9,1,1,9,9,9], [0,9,9,9,9,9,9,0], [0,0,0,0,0,0,0,0]
    ],
    DEMON: [
     
    [0,6,0,1,1,0,6,0], [1,6,1,6,6,1,6,1], [1,1,1,6,6,1,1,1], [0,1,1,6,6,1,1,0],
        [0,0,1,6,6,1,0,0], [0,0,1,3,3,1,0,0], [0,0,1,3,3,1,0,0], [0,0,1,0,0,1,0,0]
    ],
    BOSS: [ // 16x16
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0], [0,0,0,0,1,6,6,6,6,1,0,0,0,0,0,0],
        [0,0,0,1,6,6,1,6,6,6,1,0,0,0,0,0], [0,0,1,6,6,6,6,6,6,6,6,1,0,0,0,0], [0,1,6,6,6,6,6,6,6,6,6,6,1,0,0,0],
        [1,6,6,6,1,1,6,6,1,1,6,6,6,1,0,0], [1,6,6,6,6,6,6,6,6,6,6,6,6,1,0,0], [1,6,6,6,6,6,6,6,6,6,6,6,6,1,0,0],
        [0,1,6,6,6,1,1,1,1,1,6,6,6,1,0,0], [0,0,1,6,6,1,0,0,0,1,6,6,1,0,0,0], [0,0,0,1,6,1,0,0,0,1,6,1,0,0,0,0],
        [0,0,0,1,6,1,0,0,0,1,6,1,0,0,0,0], [0,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ]
};
// --- BIOMES, QUESTS, VARIABLES ---
const BIOMES = { 
    FOREST:{start:0,end:1000,color:'#27ae60',ground:'#2ecc71',asset:'TREE', mapColor: PALETTE[12]}, 
    DESERT:{start:1000,end:2000,color:'#e67e22',ground:'#f1c40f',asset:'ROCK_GOLD', mapColor: PALETTE[7]}, 
    SNOW:{start:2000,end:3000,color:'#bdc3c7',ground:'#ecf0f1',asset:'IRON_ROCK', mapColor: PALETTE[8]}, 
    VOLCANO:{start:3000,end:4000,color:'#c0392b',ground:'#2c0505',asset:'RUBY', mapColor: PALETTE[6]} 
};
const QUESTS = [ 
    { id: 0, txt: "R√©colter 10 BOIS", type: 'wood', target: 10 },
    { id: 1, txt: "Fabriquer une MAISON", type: 'house', target: 1 },
    { id: 2, txt: "R√©colter 10 PIERRES", type: 'stone', target: 10 },
    { id: 3, txt: "Am√©liorer la HACHE (Niv 2)", type: 'axe', target: 2 },
    { id: 4, txt: "Explorer le D√âSERT (Est)", type: 'explore_desert', target: 1 },
    { id: 5, txt: "Trouver 5 OR (D√©sert)", type: 'gold', target: 5 },
  
    { id: 6, txt: "Fabriquer une √âP√âE en Or (Niv 3)", type: 'sword', target: 3 },
    { id: 7, txt: "Explorer la NEIGE", type: 'explore_snow', target: 1 },
    { id: 8, txt: "Tuer 3 LOUPS Blancs", type: 'kill_wolf', target: 3 },
    { id: 9, txt: "Trouver 5 FER", type: 'iron', target: 5 },
    { id: 10, txt: "Explorer le VOLCAN (Fin)", type: 'explore_volcano', target: 1 },
    { id: 11, txt: "Tuer le ROI D√âMON", type: 'kill_boss', target: 1 },
    { 
id: 12, txt: "VOUS √äTES LE MA√éTRE DE L'√éLE !", type: 'win', target: 0 }
]; 

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
const mapCanvas = document.getElementById('fullMapCanvas');
const ctxMap = mapCanvas.getContext('2d');

let isGameRunning = true;
let lastTime = 0;
let saveTimer = 0;
let joy = { active:false, dx:0, dy:0, sx:0, sy:0 };
let keys = { z: false, q: false, s: false, d: false }; // NOUVEAU: √âtat des touches ZQSD
let game = { 
    player: { x: 500, y: 500, hp: 100, maxHp: 100, speed: 6, size: 24, angle: 0, iframes: 0 }, 
    inv: { wood:0, stone:0, gold:0, iron:0, obsi:0, axe:1, pick:1, sword:1, armor:0 }, 
    house: { active: false, x: 0, y: 0, lvl: 0, cooldown: 0 }, 
    quest: { id: 0, progress: 0 }, 
    dayTime: 0, 
    camera: { x:0, y:0 }, 
    objects: [], 
    particles: [] 
};
// --- FONCTIONS DE RENDU PIXEL ART (Inchag√©e) ---
function drawPixelArt(assetName, x, y, scale = SCALE_BASE) {
    const asset = PIXEL_ASSETS[assetName];
if (!asset) return; 
    
    const size = asset.length;
    const halfSize = (size * scale) / 2;
    
    ctx.save();
ctx.translate(x - halfSize, y - halfSize);
    
    for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
            const colorIndex = asset[r][c];
if (colorIndex !== 0) {
                ctx.fillStyle = PALETTE[colorIndex] ||
'#FF00FF';
                ctx.fillRect(c * scale, r * scale, scale, scale);
            }
        }
    }
    ctx.restore();
}


// --- WORLD GEN (Mobs r√©duits et Zone S√©curis√©e) ---
function generateWorld() {
    game.objects = [];
const spawn = (type, minX, maxX, count) => {
        for(let i=0; i<count; i++) {
            let x = minX + Math.random()*(maxX-minX);
let y = Math.random()*WORLD_H;
            createObject(type, x, y);
        }
    };
// 1. FOREST (Mobs r√©duits de 50% et ne spawnent qu'apr√®s X=500)
    spawn('tree', 0, 1000, 120);
spawn('stone', 0, 1000, 60);
    spawn('slime', SAFE_ZONE_X, 1000, 10); // Mobs: 10 (au lieu de 20) et commencent √† 500
    
    // 2. DESERT (Mobs r√©duits de 50%)
    spawn('gold_rock', 1000, 2000, 40);
spawn('scorpion', 1000, 2000, 15); // Mobs: 15 (au lieu de 30)
    
    // 3. SNOW (Mobs r√©duits de 50%)
    spawn('iron_rock', 2000, 3000, 50);
spawn('wolf', 2000, 3000, 18); // Mobs: 18 (au lieu de 35)
    
    // 4. VOLCANO (Mobs r√©duits de 50%)
    spawn('ruby', 3000, 4000, 30);
spawn('demon', 3000, 4000, 12); // Mobs: 12 (au lieu de 25)
    
    // BOSS FINAL
    createObject('boss', 3800, 2000);
for(let a=0; a<Math.PI*2; a+=0.5) createObject('wall', 3800+Math.cos(a)*400, 2000+Math.sin(a)*400);
}

function createObject(type, x, y) {
    let o = { type, x, y, hp:1, maxHp:1, size:40, asset:'STONE', solid:false, hostile:false, speed: 0, dmg: 0, mapDotColor: 'white' };
// RESSOURCES
    if(type==='tree') { o.asset='TREE'; o.hp=15; o.maxHp=15; o.size=50; o.mapDotColor=PALETTE[4]; }
    if(type==='stone') { o.asset='STONE'; o.hp=25;
o.maxHp=25; o.size=40; o.mapDotColor=PALETTE[5]; }
    if(type==='gold_rock') { o.asset='ROCK_GOLD'; o.hp=40; o.maxHp=40; o.size=35; o.mapDotColor=PALETTE[7];
}
    if(type==='iron_rock') { o.asset='IRON_ROCK'; o.hp=50; o.maxHp=50; o.size=35; o.mapDotColor=PALETTE[10]; }
    if(type==='ruby') { o.asset='RUBY'; o.hp=60; o.maxHp=60;
o.size=30; o.mapDotColor=PALETTE[9]; }
    
    // MOBS
    if(type==='slime') { o.asset='SLIME'; o.hp=30; o.maxHp=30;
o.hostile=true; o.speed=2; o.dmg=5; o.size=30; o.mapDotColor=PALETTE[4]; }
    if(type==='scorpion') { o.asset='SCORPION'; o.hp=60; o.maxHp=60; o.hostile=true; o.speed=4; o.dmg=10; o.size=25; o.mapDotColor=PALETTE[6];
}
    if(type==='wolf') { o.asset='WOLF'; o.hp=100; o.maxHp=100; o.hostile=true; o.speed=5; o.dmg=15; o.size=35; o.mapDotColor=PALETTE[2];
}
    if(type==='demon') { o.asset='DEMON'; o.hp=150; o.maxHp=150; o.hostile=true; o.speed=3.5; o.dmg=25; o.size=35; o.mapDotColor=PALETTE[6];
}
    if(type==='boss') { o.asset='BOSS'; o.hp=1000; o.maxHp=1000; o.hostile=true; o.speed=4.5; o.dmg=40; o.size=80; o.isBoss=true; o.mapDotColor=PALETTE[6];
}

    // OTHER
    if(type==='wall') { o.asset='STONE'; o.hp=9999; o.solid=true; o.size=40; o.mapDotColor=PALETTE[1];
}
    
    game.objects.push(o);
}


// --- GAME LOOP & CORE FUNCTIONS (Unchanged logic) ---
function loop(time) {
    if(!isGameRunning) return;
let dt = time - lastTime;
    lastTime = time;

    update(dt);
    draw();
    updateUI();
if(game.player.hp <= 0) {
        showDeathScreen();
        return;
    }

    saveTimer += dt;
if(saveTimer > 10000) { saveGame(); saveTimer = 0; }

    requestAnimationFrame(loop);
}

function update(dt) {
    // Player Move
    // MODIFI√â: V√©rifier si le joystick OU le clavier est actif
    if(joy.active || keys.z || keys.q || keys.s || keys.d) {
        let moveAngle = game.player.angle; // Commence par l'angle de vis√©e (souris ou joystick)

        // NOUVEAU: Si une touche ZQSD est press√©e, recalculer l'angle de d√©placement
        if (!joy.active && (keys.z || keys.q || keys.s || keys.d)) {
            let dx = 0;
            let dy = 0;
            if (keys.z) dy -= 1; // Z/W: Haut
            if (keys.s) dy += 1; // S: Bas
            if (keys.q) dx -= 1; // Q/A: Gauche
            if (keys.d) dx += 1; // D: Droite
            
            // Calculer l'angle de d√©placement (pour le mouvement uniquement)
            if (dx !== 0 || dy !== 0) {
                moveAngle = Math.atan2(dy, dx);
            }
        }
        
        let nx = game.player.x + Math.cos(moveAngle) * game.player.speed; // Utilise moveAngle
        let ny = game.player.y + Math.sin(moveAngle) * game.player.speed; // Utilise moveAngle
        
        nx = Math.max(0, Math.min(WORLD_W, nx));
        ny = Math.max(0, Math.min(WORLD_H, ny));
        
        let collide = game.objects.some(o => o.solid && Math.hypot(nx-o.x, ny-o.y) < game.player.size + o.size/2);
        if(!collide) { game.player.x = nx;
        game.player.y = ny; }
        
        // Quest Check
        if(nx > 1000 && nx < 2000) checkQuest('explore_desert', 1);
        if(nx > 2000 && nx < 3000) checkQuest('explore_snow', 1);
        if(nx > 3000) checkQuest('explore_volcano', 1);
    }
    
    // Camera, Mobs, Healing, DayCycle... (Logic from V8)
    game.camera.x = game.player.x - canvas.width/2;
game.camera.y = game.player.y - canvas.height/2;

    if(game.player.iframes > 0) game.player.iframes--;

    game.objects.forEach(o => {
        if(o.hostile && o.hp > 0) {
            let dist = Math.hypot(game.player.x - o.x, game.player.y - o.y);
            if(dist < 400) { 
                o.x += (game.player.x - o.x) / dist * o.speed;
                
o.y += (game.player.y - o.y) / dist * o.speed;
                
                if(dist < game.player.size + o.size/2 && game.player.iframes <= 0) {
                    game.player.hp -= o.dmg;
                    game.player.iframes = 40;
                    createFloatText(`-${o.dmg}`, game.player.x, game.player.y, 'red');
                }
            }
        }
    });

    if(game.house.active) {
        let dist = Math.hypot(game.player.x - game.house.x, game.player.y - game.house.y);
        if(dist < 100) {
            game.house.cooldown++;
            if(game.house.cooldown > (60 - game.house.lvl*10) && game.player.hp < game.player.maxHp) {
                game.player.hp = Math.min(game.player.maxHp, game.player.hp + 2);
                game.house.cooldown = 0;
                createFloatText("üíö", game.player.x, game.player.y-30, '#2ecc71');
            }
        }
    }

    game.dayTime += 0.0005;
    if(game.dayTime > 1) game.dayTime = 0;
}

// --- RENDU CARTE COMPL√àTE (NOUVEAU) ---
function showFullMapModal() {
    document.getElementById('map-modal').style.display = 'block';
    // Le canvas de la carte est redessin√© chaque fois qu'on ouvre le modal
    drawFullMap();
}

function drawFullMap() {
    const mapSize = 500;
    mapCanvas.width = mapSize;
    mapCanvas.height = mapSize;
    const scale = mapSize / WORLD_W;
    
    // Remplir le fond de la carte par biome
    for (let biomeName in BIOMES) {
        const biome = BIOMES[biomeName];
        ctxMap.fillStyle = biome.mapColor;
        ctxMap.fillRect(biome.start * scale, 0, (biome.end - biome.start) * scale, mapSize);
    }

    // Dessin des RESSOURCES et MOBS
    for (let o of game.objects) {
        if (o.type === 'wall' || o.hp <= 0) continue;
        ctxMap.fillStyle = o.mapDotColor;
        // Dessiner en petit cercle pour les ressources/mobs
        ctxMap.beginPath();
        ctxMap.arc(o.x * scale, o.y * scale, o.isBoss ? 4 : 2, 0, Math.PI * 2);
        ctxMap.fill();
    }
    
    // Dessin de la MAISON
    if (game.house.active) {
        ctxMap.fillStyle = 'lime';
        ctxMap.fillRect(game.house.x * scale - 3, game.house.y * scale - 3, 6, 6);
    }
    
    // Dessin du JOUEUR
    ctxMap.fillStyle = 'red';
    ctxMap.beginPath();
    ctxMap.arc(game.player.x * scale, game.player.y * scale, 5, 0, Math.PI * 2);
    ctxMap.fill();
    ctxMap.strokeStyle = 'white';
    ctxMap.lineWidth = 1;
    ctxMap.stroke();
}


// --- ACTIONS & UI (Unchanged logic) ---
function handleAction() {
    let t = getNearestTarget();
    if(!t) return;
    
    let dmg = 1;
    if(t.hostile) dmg = game.inv.sword * 6;
    else if(t.type === 'tree') dmg = game.inv.axe * 3;
    else dmg = game.inv.pick * 3;

    t.hp -= dmg;
    t.hitAnim = 5;
    createFloatText("üí•", t.x, t.y, '#fff');

    if(t.hp <= 0) {
        if(t.type === 'tree') { game.inv.wood += 5; checkQuest('wood', 5); createFloatText("+5 BOIS", t.x, t.y, '#2ecc71'); }
        if(t.type === 'stone') { game.inv.stone += 3; checkQuest('stone', 3); createFloatText("+3 PIERRE", t.x, t.y, '#95a5a6'); }
        if(t.type === 'gold_rock') { game.inv.gold += 2; checkQuest('gold', 2); createFloatText("+2 OR", t.x, t.y, 'gold'); }
        if(t.type === 'iron_rock') { game.inv.iron += 2; checkQuest('iron', 2); createFloatText("+2 FER", t.x, t.y, '#fff'); }
        if(t.type === 'ruby') { game.inv.ruby += 1; createFloatText("+1 RUBIS", t.x, t.y, '#e91e63'); }
        if(t.type === 'wolf') checkQuest('kill_wolf', 1);
        if(t.type === 'boss') checkQuest('kill_boss', 1);

        game.objects.splice(game.objects.indexOf(t), 1);
    }
}

function getNearestTarget() {
    let closest = null, minDist = 120;
    // On recherche la cible la plus proche DANS L'ANGLE DE VIS√âE (game.player.angle)
    for(let o of game.objects) {
        if(o.type === 'wall') continue;
        let d = Math.hypot(game.player.x - o.x, game.player.y - o.y);
        
        // Check si la cible est dans un c√¥ne de 45 degr√©s devant le joueur (pour rendre la vis√©e √† la souris utile)
        let angleToTarget = Math.atan2(o.y - game.player.y, o.x - game.player.x);
        let angleDiff = Math.abs(game.player.angle - angleToTarget);
        if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff; // Handle wrap-around
        
        if(d < minDist && angleDiff < 0.39) { // 0.39 radians = ~22.5 degr√©s (c√¥ne total de 45 degr√©s)
            minDist = d;
            closest = o;
        }
    }
    return closest;
}

game.craft = (item) => {
    let msg = null;
    // HOUSE
    if(item === 'house') {
        if(game.house.lvl >= 3) return;
        let costs = [
            {w: 50, s: 50}, // Lvl 1
            {w: 100, s: 100, g: 10}, // Lvl 2
            {w: 200, s: 200, i: 10, ob: 5} // Lvl 3
        ];
        let c = costs[game.house.lvl];
        
        let hasMaterials = (!c.w || game.inv.wood >= c.w) && (!c.s || game.inv.stone >= c.s) && (!c.g || game.inv.gold >= c.g) && (!c.i || game.inv.iron >= c.i) && (!c.ob || game.inv.obsi >= c.ob);
        
        if(!hasMaterials) return;
        
        game.inv.wood -= c.w || 0;
        game.inv.stone -= c.s || 0;
        game.inv.gold -= c.g || 0;
        game.inv.iron -= c.i || 0;
        game.inv.obsi -= c.ob || 0;
        
        if(!game.house.active) {
            game.house.active = true;
            game.house.x = game.player.x;
            game.house.y = game.player.y;
            checkQuest('house', 1);
        }
        game.house.lvl++;
        msg = "MAISON AM√âLIOR√âE";
    }

    // ARMOR
    if(item === 'armor') {
        if(!game.house.active) return;
        let costs = [{s:50,w:50},{s:100,i:10},{s:200,ob:5}];
        if(game.inv.armor >= 3) return;
        let c = costs[game.inv.armor];
        let ok = false;

        if(game.inv.armor==0 && game.inv.stone>=c.s && game.inv.wood>=c.w) { game.inv.stone-=c.s; game.inv.wood-=c.w; ok=true; }
        if(game.inv.armor==1 && game.inv.stone>=c.s && game.inv.iron>=c.i) { game.inv.stone-=c.s; game.inv.iron-=c.i; ok=true; }
        if(game.inv.armor==2 && game.inv.stone>=c.s && game.inv.obsi>=c.ob) { game.inv.stone-=c.s; game.inv.obsi-=c.ob; ok=true; }
        
        if(ok) {
            game.inv.armor++;
            game.player.maxHp += 100;
            game.player.hp = game.player.maxHp;
            msg = "ARMURE √âQUIP√âE";
        }
    }
    // TOOLS
    if(item === 'axe' && game.inv.wood >= game.inv.axe*20) { game.inv.wood -= game.inv.axe*20; game.inv.axe++; checkQuest('axe', 1); msg="HACHE UP !"; }
    if(item === 'pick' && game.inv.wood >= 20 && game.inv.stone >= 20) { game.inv.wood-=20; game.inv.stone-=20; game.inv.pick++; msg="PIOCHE UP !"; }
    if(item === 'sword' && game.inv.wood >= 50 && game.inv.gold >= game.inv.sword*5) { game.inv.wood-=50; game.inv.gold-=game.inv.sword*5; game.inv.sword++; checkQuest('sword', 1); msg="√âP√âE UP !"; }

    if(msg) { createFloatText(msg, game.player.x, game.player.y, '#fff'); updateUI(); }
};

function updateUI() {
    document.getElementById('hud-hp').innerText = Math.floor(game.player.hp) + "/" + game.player.maxHp;
    document.getElementById('hud-wood').innerText = game.inv.wood;
    document.getElementById('hud-stone').innerText = game.inv.stone;
    document.getElementById('hud-gold').innerText = game.inv.gold;
    document.getElementById('hud-iron').innerText = game.inv.iron;
    document.getElementById('hud-obsi').innerText = game.inv.obsi;
    // Quest
    let q = QUESTS[game.quest.id];
    document.getElementById('quest-txt').innerText = q ?
    `${q.txt} (${game.quest.progress}/${q.target})` : "TOUTES QU√äTES FINIES !";
    // Action Button Icon
    let btn = document.getElementById('action-btn');
    let t = getNearestTarget();
    if(t) {
        if(t.hostile) { btn.innerText = "üó°Ô∏è"; btn.style.background = "#c0392b"; }
        else if(t.type === 'tree') { btn.innerText = "ü™ì"; btn.style.background = "#e67e22"; }
        else { btn.innerText = "‚õèÔ∏è"; btn.style.background = "#7f8c8d"; }
    } else {
        btn.innerText = "‚öîÔ∏è";
        btn.style.background = "#95a5a6";
    }
    // Menu Texts (Dynamique)
    document.getElementById('house-lvl').innerText = game.house.lvl;
    document.getElementById('armor-lvl').innerText = game.inv.armor;
    document.getElementById('axe-lvl-menu').innerText = "Niv " + game.inv.axe;
    document.getElementById('pick-lvl-menu').innerText = "Niv " + game.inv.pick;
    document.getElementById('sword-lvl-menu').innerText = "Niv " + game.inv.sword;
    document.getElementById('axe-cost').innerText = (game.inv.axe*20) + " Bois";
    let costPick = (game.inv.pick === 1) ? "20B + 20P" : "40B + 40P";
    document.getElementById('pick-cost').innerText = costPick;
    document.getElementById('sword-cost').innerText = "50B + " + (game.inv.sword*5) + " Or";
    
    // House Costs
    let houseCost = 'MAX';
    if(game.house.lvl === 0) houseCost = '50B + 50P';
    else if(game.house.lvl === 1) houseCost = '100B + 100P + 10O';
    else if(game.house.lvl === 2) houseCost = '200B + 200P + 10F + 5O';
    document.getElementById('house-cost').innerText = houseCost;
    document.getElementById('house-desc').innerText = "Soin passif √† domicile (Heal: " + (game.house.lvl*2) + " PV)";

    // Armor Costs
    let armorCost = 'MAX';
    let armorDesc = "Armure actuelle : " + game.inv.armor;
    if(game.inv.armor === 0) { armorCost = '50P + 50B'; armorDesc = "+100 PV Max (N√©cessite Maison)"; }
    else if(game.inv.armor === 1) armorCost = '100P + 10F';
    else if(game.inv.armor === 2) armorCost = '200P + 5 Obsi';
    document.getElementById('armor-cost').innerText = armorCost;
    document.getElementById('btn-armor').innerText = (game.inv.armor >= 3) ? 'MAX' : 'FORGER';
    document.getElementById('btn-armor').disabled = (game.inv.armor >= 3) || !game.house.active;
}


// --- RENDU (Unchanged logic) ---
function draw() {
    ctx.fillStyle = getGroundColor();
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const playerScreenX = canvas.width / 2;
    const playerScreenY = canvas.height / 2;

    // Draw Objects
    game.objects.sort((a,b) => a.y - b.y);
    game.objects.forEach(o => {
        const ox = o.x - game.camera.x;
        const oy = o.y - game.camera.y;
        if(ox > -100 && ox < canvas.width + 100 && oy > -100 && oy < canvas.height + 100) {
            
            // Draw House
            if(o.type.startsWith('house')) {
                const asset = (o.type === 'house_lvl1') ? 'HOUSE_LVL1' : 'HOUSE_LVL2'; // Remplacer par l'asset r√©el
                drawPixelArt(asset, ox, oy, SCALE_BASE*2);
            } else {
                drawPixelArt(o.asset, ox, oy);
            }

            // Draw Health Bar
            if(o.hp < o.maxHp && o.hp > 0) {
                const barW = 40;
                const barH = 5;
                const barX = ox - barW/2;
                const barY = oy - 40;
                ctx.fillStyle = 'black';
                ctx.fillRect(barX - 1, barY - 1, barW + 2, barH + 2);
                ctx.fillStyle = 'red';
                ctx.fillRect(barX, barY, barW, barH);
                ctx.fillStyle = 'lime';
                ctx.fillRect(barX, barY, barW * (o.hp/o.maxHp), barH);
            }
        }
    });

    // Draw Player
    ctx.save();
    ctx.translate(playerScreenX, playerScreenY);
    ctx.rotate(game.player.angle + Math.PI/2); // Rotation pour faire face √† l'angle
    
    // Si la cible est √† gauche, on inverse l'asset pour l'effet miroir
    let closestTarget = getNearestTarget();
    let isFlipped = false;
    if (closestTarget) {
        let angleToTarget = Math.atan2(closestTarget.y - game.player.y, closestTarget.x - game.player.x);
        let angleDiff = game.player.angle - angleToTarget;
        if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
        if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

        if (angleDiff > 0) { // Si la cible est √† gauche de l'angle de vis√©e, on ne flip pas.
             // On utilise la vis√©e de la souris, donc l'angle de vis√©e est l'angle du joueur
            if(Math.cos(game.player.angle) < 0) isFlipped = true;
        } else {
            if(Math.cos(game.player.angle) < 0) isFlipped = true;
        }
    }


    if (isFlipped) {
         ctx.scale(1, -1);
    }
    
    // Choix de l'asset
    let playerAsset = (closestTarget && closestTarget.hp > 0) ? 'PLAYER_SWORD' : 'PLAYER_IDLE';
    drawPixelArt(playerAsset, 0, 0, SCALE_BASE);
    
    ctx.restore();

    // Draw Player HP
    const hpText = `HP: ${Math.floor(game.player.hp)}/${game.player.maxHp}`;
    ctx.fillStyle = 'red';
    ctx.font = `${SCALE_BASE*5}px 'Pixelated MS Sans Serif'`;
    ctx.fillText(hpText, playerScreenX - ctx.measureText(hpText).width/2, playerScreenY + 50);

    // Draw Particles & Float Text (Not included here for brevity, but assume drawParticles() is called)
    drawParticles(dt);

    // Night/Day Overlay
    const nightOverlay = document.getElementById('night-overlay');
    nightOverlay.style.opacity = Math.abs(game.dayTime - 0.5) * 2;
}

function drawParticles(dt) {
    // Basic particle logic, not fully included to save space
    game.particles = game.particles.filter(p => p.life > 0);
    game.particles.forEach(p => {
        p.x += p.vx * dt/1000 * 60;
        p.y += p.vy * dt/1000 * 60;
        p.life -= dt;
        ctx.fillStyle = p.color;
        ctx.font = p.font;
        ctx.fillText(p.text, p.x - game.camera.x, p.y - game.camera.y);
    });
}

function createFloatText(text, x, y, color, font = 'bold 20px "Pixelated MS Sans Serif"') {
    game.particles.push({ text, x, y, vx: 0, vy: -1, color, life: 40, font });
}

function getGroundColor() {
    // D√©terminer la couleur de fond en fonction de la position X du joueur
    const x = game.player.x;
    for(let biomeName in BIOMES) {
        const biome = BIOMES[biomeName];
        if(x >= biome.start && x < biome.end) {
            return biome.ground;
        }
    }
    return 'black';
}

function init() {
    // Resize on start
    resize();
    // Load existing game or generate world
    if(!loadGame()) generateWorld();
    
    // Init Inputs (Touch & PC)
    initInputs();

    // Start Loop
    requestAnimationFrame(loop);
}

function initInputs() {
    const joyZone = document.getElementById('joystick-zone');
    const stick = document.getElementById('joystick-stick');
    const actionBtn = document.getElementById('action-btn');
    const menuBtn = document.getElementById('menu-btn');

    // --- JOUEUR (LOGIQUE TACTILE EXISTANTE) ---
    const moveJoystick = (e) => {
        const rect = joyZone.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        // Calculer la position relative de la touche
        const touchX = e.touches[0].clientX;
        const touchY = e.touches[0].clientY;
        
        joy.dx = touchX - centerX;
        joy.dy = touchY - centerY;
        
        // Limiter le d√©placement du stick √† 40px
        const maxDist = 40;
        const dist = Math.min(Math.hypot(joy.dx, joy.dy), maxDist);
        const angle = Math.atan2(joy.dy, joy.dx);
        
        const stickX = 35 + Math.cos(angle)*dist;
        const stickY = 35 + Math.sin(angle)*dist;
        stick.style.left = `${stickX}px`;
        stick.style.top = `${stickY}px`;
        
        // Mettre √† jour l'angle du joueur pour le mouvement ET la vis√©e
        game.player.angle = angle; 
    };
    
    joyZone.addEventListener('touchstart', e => {
        joy.active = true;
        joy.sx = e.touches[0].clientX; joy.sy = e.touches[0].clientY;
        e.preventDefault();
    }, {passive:false});
    joyZone.addEventListener('touchmove', e => { if(joy.active) moveJoystick(e); e.preventDefault(); }, {passive:false});

    const endJoy = () => { 
        joy.active = false; 
        stick.style.left = '35px';
        stick.style.top = '35px';
    };
    joyZone.addEventListener('touchend', endJoy);
    
    // Bouton d'action mobile
    actionBtn.addEventListener('touchstart', e=>{ e.preventDefault(); handleAction(); });
    actionBtn.addEventListener('mousedown', e=>{ e.preventDefault(); handleAction(); });

    // --- NOUVEAU: Input Clavier (ZQSD/WASD) ---
    document.addEventListener('keydown', (e) => {
        const key = e.key.toLowerCase();
        if (key === 'z' || key === 'w') { keys.z = true; } // Z pour AZERTY, W pour QWERTY (Haut)
        if (key === 'q' || key === 'a') { keys.q = true; } // Q pour AZERTY, A pour QWERTY (Gauche)
        if (key === 's') { keys.s = true; } // S (Bas)
        if (key === 'd') { keys.d = true; } // D (Droite)
        
        // Emp√™cher le d√©filement du navigateur
        if (keys.z || keys.q || keys.s || keys.d) {
            e.preventDefault();
        }
    });

    document.addEventListener('keyup', (e) => {
        const key = e.key.toLowerCase();
        if (key === 'z' || key === 'w') { keys.z = false; }
        if (key === 'q' || key === 'a') { keys.q = false; }
        if (key === 's') { keys.s = false; }
        if (key === 'd') { keys.d = false; }
    });


    // --- NOUVEAU: Input Souris (Vis√©e et Action) ---
    
    // 1. Viser avec la souris
    canvas.addEventListener('mousemove', (e) => {
        // Calculer la position du joueur au centre de l'√©cran
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        
        // Calculer la direction de la souris par rapport au centre du joueur
        const dx = e.clientX - centerX;
        const dy = e.clientY - centerY;
        
        // Mettre √† jour l'angle de vis√©e du joueur (utilis√© pour l'√©p√©e/l'outil)
        game.player.angle = Math.atan2(dy, dx);
    });

    // 2. Attaquer/R√©colter avec le clic de la souris
    canvas.addEventListener('mousedown', (e) => {
        // Emp√™che le clic d'activer la s√©lection de texte ou d'autres actions par d√©faut
        e.preventDefault(); 

        // On v√©rifie que l'on clique bien sur le canvas (et non un bouton UI par-dessus)
        if (e.target.id === 'gameCanvas') {
             handleAction();
        }
    });
    
    menuBtn.addEventListener('click', () => {
        document.getElementById('craft-menu').style.display = 'block';
        updateUI();
    });
}

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    document.getElementById('rotate-msg').style.display = (window.innerWidth < window.innerHeight && window.innerWidth < 800) ? 'flex' : 'none';
}

// --- DEATH / SAVE / LOAD / INPUTS (Unchanged logic) ---
function showDeathScreen() {
    isGameRunning = false;
    const deathScreen = document.getElementById('death-screen');
    const respawnBtn = document.getElementById('btn-respawn');
    const hasValidSave = localStorage.getItem('rpg_save_v7') !== null;

    if (game.house.active && hasValidSave) {
        respawnBtn.disabled = false;
        respawnBtn.innerText = "üè° Revenir √† la Maison (Gratuit)";
    } else {
        respawnBtn.disabled = true;
        respawnBtn.innerText = "‚ùå Maison non b√¢tie / Sauvegarde introuvable";
        respawnBtn.style.backgroundColor = '#555';
        respawnBtn.style.borderBottomColor = '#333';
    }
    deathScreen.style.display = 'block';
}

window.deathMenuAction = (action) => {
    if (action === 'restart') {
        localStorage.removeItem('rpg_save_v7');
        location.reload();
    } else if (action === 'respawn') {
        if (!document.getElementById('btn-respawn').disabled) {
            loadGame(true);
            document.getElementById('death-screen').style.display = 'none';
            isGameRunning = true;
            requestAnimationFrame(loop);
        }
    }
};

function saveGame() {
    const data = { p: {x:game.player.x, y:game.player.y, hp:game.player.hp, max:game.player.maxHp}, inv: game.inv, house: game.house, quest: game.quest, objs: game.objects.filter(o => o.type==='wall' || (o.isBoss && o.hp<o.maxHp)) };
    localStorage.setItem('rpg_save_v7', JSON.stringify(data));
    let notif = document.getElementById('save-notif');
    notif.style.display = 'block';
    setTimeout(() => notif.style.display='none', 2000);
}

function loadGame(isRespawn = false) {
    const raw = localStorage.getItem('rpg_save_v7');
    if(!raw) return false;
    try {
        const d = JSON.parse(raw);
        game.player.x = d.p.x;
        game.player.y = d.p.y;
        game.player.hp = d.p.hp;
        game.player.maxHp = d.p.max;
        game.inv = d.inv;
        game.house = d.house;
        game.quest = d.quest;
        game.objects = d.objs;
        
        // Respawn logic (teleport to home if needed)
        if(isRespawn && game.house.active) {
            game.player.x = game.house.x;
            game.player.y = game.house.y;
            game.player.hp = game.player.maxHp;
        }

        updateUI();
        return true;
    } catch (e) {
        console.error("Erreur de chargement de la sauvegarde", e);
        return false;
    }
}

window.addEventListener('resize', resize);
window.addEventListener('load', init);
</script>
</body>
</html>
